ПРИЛОЖЕНИЕ А

(обязательное)

Листинг исходного кода программы

Файл CaForecast.Core/CaForecaster.cs
--------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using System.Linq;

namespace CaForecast.Core;

public class CaForecaster
{
    public ForecastResult Forecast(
        IReadOnlyList<double> prices,
        IReadOnlyList<double> returns,
        IReadOnlyList<int> encodedStates,
        int trainReturnsCount,
        int memory,
        double alpha,
        CaRuleTrainer trainer,
        MetricsService metricsService)
    {
        if (prices is null)
        {
            throw new ArgumentNullException(nameof(prices));
        }

        if (returns is null)
        {
            throw new ArgumentNullException(nameof(returns));
        }

        if (encodedStates is null)
        {
            throw new ArgumentNullException(nameof(encodedStates));
        }

        if (trainer is null)
        {
            throw new ArgumentNullException(nameof(trainer));
        }

        if (metricsService is null)
        {
            throw new ArgumentNullException(nameof(metricsService));
        }

        if (returns.Count != encodedStates.Count)
        {
            throw new ArgumentException("Длины массивов доходностей и закодированных состояний должны совпадать.");
        }

        if (trainReturnsCount <= memory || trainReturnsCount >= returns.Count)
        {
            throw new ArgumentOutOfRangeException(nameof(trainReturnsCount), "Размер обучающей выборки должен быть больше памяти и меньше общего числа доходностей.");
        }

        var trainStates = encodedStates.Take(trainReturnsCount).ToArray();
        var trainReturns = returns.Take(trainReturnsCount).ToArray();
        var model = trainer.Train(trainStates, trainReturns, memory, alpha);

        var actualReturns = new List<double>();
        var predictedReturns = new List<double>();
        var actualPrices = new List<double>();
        var predictedPrices = new List<double>();

        var currentPredictedPrice = prices[trainReturnsCount];

        for (var t = trainReturnsCount; t < returns.Count; t++)
        {
            var pattern = BuildPattern(encodedStates, t - memory, memory);
            var probabilities = model.TransitionProbabilities.TryGetValue(pattern, out var p)
                ? p
                : model.GlobalDistribution;

            var predictedState = ArgMaxState(probabilities);
            var predictedReturn = model.MeanReturnsByState[predictedState];

            actualReturns.Add(returns[t]);
            predictedReturns.Add(predictedReturn);

            var actualPrice = prices[t + 1];
            actualPrices.Add(actualPrice);

            currentPredictedPrice *= Math.Exp(predictedReturn);
            predictedPrices.Add(currentPredictedPrice);
        }

        var mae = metricsService.CalculateMae(actualPrices, predictedPrices);
        var mse = metricsService.CalculateMse(actualPrices, predictedPrices);
        var rmse = metricsService.CalculateRmse(actualPrices, predictedPrices);
        var mapePercent = metricsService.CalculateMapePercent(actualPrices, predictedPrices);

        return new ForecastResult
        {
            Memory = memory,
            TrainReturnsCount = trainReturnsCount,
            ActualReturns = actualReturns,
            PredictedReturns = predictedReturns,
            ActualPrices = actualPrices,
            PredictedPrices = predictedPrices,
            Mae = mae,
            Mse = mse,
            Rmse = rmse,
            MapePercent = mapePercent
        };
    }

    private static string BuildPattern(IReadOnlyList<int> states, int start, int memory)
    {
        return string.Join('|', states.Skip(start).Take(memory));
    }

    private static int ArgMaxState(IReadOnlyList<double> probs)
    {
        var index = 0;
        var max = probs[0];
        for (var i = 1; i < probs.Count; i++)
        {
            if (probs[i] > max)
            {
                max = probs[i];
                index = i;
            }
        }

        return index switch
        {
            0 => -1,
            1 => 0,
            2 => 1,
            _ => 0
        };
    }
}

================================================================================

Файл CaForecast.Core/CaRuleModel.cs
--------------------------------------------------------------------------------
namespace CaForecast.Core;

public sealed class CaRuleModel
{
    public CaRuleModel(int memory, Dictionary<string, double[]> transitionProbabilities, Dictionary<int, double> meanReturnsByState)
    {
        Memory = memory;
        TransitionProbabilities = transitionProbabilities;
        MeanReturnsByState = meanReturnsByState;
    }

    public int Memory { get; }

    public IReadOnlyDictionary<string, double[]> TransitionProbabilities { get; }

    public IReadOnlyDictionary<int, double> MeanReturnsByState { get; }

    public double[] GlobalDistribution { get; init; } = { 1.0 / 3.0, 1.0 / 3.0, 1.0 / 3.0 };
}

================================================================================

Файл CaForecast.Core/CaRuleTrainer.cs
--------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using System.Linq;

namespace CaForecast.Core;

public class CaRuleTrainer
{
    private static readonly int[] StateValues = { -1, 0, 1 };

    public CaRuleModel Train(IReadOnlyList<int> states, IReadOnlyList<double> returns, int memory, double alpha)
    {
        if (states is null)
        {
            throw new ArgumentNullException(nameof(states));
        }

        if (returns is null)
        {
            throw new ArgumentNullException(nameof(returns));
        }

        if (states.Count != returns.Count)
        {
            throw new ArgumentException("Массивы состояний и доходностей должны иметь одинаковую длину.");
        }

        if (states.Count <= memory)
        {
            throw new ArgumentException("Обучающая выборка слишком короткая для выбранной памяти.");
        }

        if (memory < 1)
        {
            throw new ArgumentOutOfRangeException(nameof(memory), "Память должна быть >= 1.");
        }

        if (alpha < 0)
        {
            throw new ArgumentOutOfRangeException(nameof(alpha), "alpha должен быть неотрицательным.");
        }

        var countsByPattern = new Dictionary<string, double[]>(StringComparer.Ordinal);
        var globalCounts = new double[3];

        for (var t = memory; t < states.Count; t++)
        {
            var pattern = BuildPattern(states, t - memory, memory);
            var nextStateIndex = ToIndex(states[t]);

            if (!countsByPattern.TryGetValue(pattern, out var counts))
            {
                counts = new double[3];
                countsByPattern[pattern] = counts;
            }

            counts[nextStateIndex]++;
            globalCounts[nextStateIndex]++;
        }

        var transitionProbabilities = new Dictionary<string, double[]>(countsByPattern.Count, StringComparer.Ordinal);
        foreach (var pair in countsByPattern)
        {
            transitionProbabilities[pair.Key] = ApplyLaplace(pair.Value, alpha);
        }

        var globalDistribution = ApplyLaplace(globalCounts, alpha);
        var meanReturnsByState = BuildMeanReturnsByState(states, returns);

        return new CaRuleModel(memory, transitionProbabilities, meanReturnsByState)
        {
            GlobalDistribution = globalDistribution
        };
    }

    private static Dictionary<int, double> BuildMeanReturnsByState(IReadOnlyList<int> states, IReadOnlyList<double> returns)
    {
        var sums = new Dictionary<int, double>
        {
            [-1] = 0.0,
            [0] = 0.0,
            [1] = 0.0
        };

        var counts = new Dictionary<int, int>
        {
            [-1] = 0,
            [0] = 0,
            [1] = 0
        };

        for (var i = 0; i < states.Count; i++)
        {
            var state = states[i];
            sums[state] += returns[i];
            counts[state]++;
        }

        var result = new Dictionary<int, double>(3);
        foreach (var state in StateValues)
        {
            result[state] = counts[state] == 0 ? 0.0 : sums[state] / counts[state];
        }

        return result;
    }

    private static string BuildPattern(IReadOnlyList<int> states, int start, int memory)
    {
        return string.Join('|', states.Skip(start).Take(memory));
    }

    private static int ToIndex(int state)
    {
        return state switch
        {
            -1 => 0,
            0 => 1,
            1 => 2,
            _ => throw new ArgumentOutOfRangeException(nameof(state), "Состояние должно быть -1, 0 или 1.")
        };
    }

    private static double[] ApplyLaplace(IReadOnlyList<double> counts, double alpha)
    {
        var adjusted = counts.Select(x => x + alpha).ToArray();
        var total = adjusted.Sum();

        if (total <= 0)
        {
            return new[] { 1.0 / 3.0, 1.0 / 3.0, 1.0 / 3.0 };
        }

        return adjusted.Select(x => x / total).ToArray();
    }
}

================================================================================

Файл CaForecast.Core/ForecastResult.cs
--------------------------------------------------------------------------------
using System.Collections.Generic;

namespace CaForecast.Core;

public class ForecastResult
{
    public int Memory { get; init; }

    public int TrainReturnsCount { get; init; }

    public IReadOnlyList<double> ActualReturns { get; init; } = new List<double>();

    public IReadOnlyList<double> PredictedReturns { get; init; } = new List<double>();

    public IReadOnlyList<double> ActualPrices { get; init; } = new List<double>();

    public IReadOnlyList<double> PredictedPrices { get; init; } = new List<double>();

    public double Mae { get; init; }

    public double Mse { get; init; }

    public double Rmse { get; init; }

    public double MapePercent { get; init; }
}

================================================================================

Файл CaForecast.Core/MetricsService.cs
--------------------------------------------------------------------------------
using System;
using System.Collections.Generic;

namespace CaForecast.Core;

public class MetricsService
{
    public double CalculateMae(IReadOnlyList<double> actual, IReadOnlyList<double> predicted)
    {
        Validate(actual, predicted);

        var sum = 0.0;
        for (var i = 0; i < actual.Count; i++)
        {
            sum += Math.Abs(actual[i] - predicted[i]);
        }

        return sum / actual.Count;
    }

    public double CalculateMse(IReadOnlyList<double> actual, IReadOnlyList<double> predicted)
    {
        Validate(actual, predicted);

        var sum = 0.0;
        for (var i = 0; i < actual.Count; i++)
        {
            var diff = actual[i] - predicted[i];
            sum += diff * diff;
        }

        return sum / actual.Count;
    }

    public double CalculateRmse(IReadOnlyList<double> actual, IReadOnlyList<double> predicted)
    {
        return Math.Sqrt(CalculateMse(actual, predicted));
    }

    public double CalculateMapePercent(IReadOnlyList<double> actual, IReadOnlyList<double> predicted)
    {
        Validate(actual, predicted);

        var sum = 0.0;
        var count = 0;
        for (var i = 0; i < actual.Count; i++)
        {
            var absActual = Math.Abs(actual[i]);
            if (absActual < 1e-12)
            {
                continue;
            }

            sum += Math.Abs((actual[i] - predicted[i]) / absActual);
            count++;
        }

        if (count == 0)
        {
            throw new ArgumentException("MAPE нельзя рассчитать, когда все фактические значения равны нулю.");
        }

        return 100.0 * (sum / count);
    }

    private static void Validate(IReadOnlyList<double> actual, IReadOnlyList<double> predicted)
    {
        if (actual is null)
        {
            throw new ArgumentNullException(nameof(actual));
        }

        if (predicted is null)
        {
            throw new ArgumentNullException(nameof(predicted));
        }

        if (actual.Count == 0 || predicted.Count == 0)
        {
            throw new ArgumentException("Входные коллекции не должны быть пустыми.");
        }

        if (actual.Count != predicted.Count)
        {
            throw new ArgumentException("Входные коллекции должны иметь одинаковую длину.");
        }
    }
}

================================================================================

Файл CaForecast.Core/ReturnCalculator.cs
--------------------------------------------------------------------------------
using System;
using System.Collections.Generic;

namespace CaForecast.Core;

public class ReturnCalculator
{
    public IReadOnlyList<double> CalculateLogReturns(IReadOnlyList<double> prices)
    {
        if (prices is null)
        {
            throw new ArgumentNullException(nameof(prices));
        }

        if (prices.Count < 2)
        {
            throw new ArgumentException("Требуется минимум две цены.", nameof(prices));
        }

        var returns = new List<double>(prices.Count - 1);
        for (var i = 1; i < prices.Count; i++)
        {
            var previous = prices[i - 1];
            var current = prices[i];

            if (previous <= 0 || current <= 0)
            {
                throw new ArgumentException("Цены должны быть положительными для расчета лог-доходности.", nameof(prices));
            }

            returns.Add(Math.Log(current / previous));
        }

        return returns;
    }
}

================================================================================

Файл CaForecast.Core/ThreeColorEncoder.cs
--------------------------------------------------------------------------------
using System;
using System.Collections.Generic;

namespace CaForecast.Core;

public class ThreeColorEncoder
{
    public IReadOnlyList<int> Encode(IReadOnlyList<double> returns, double k)
    {
        if (returns is null)
        {
            throw new ArgumentNullException(nameof(returns));
        }

        if (k < 0)
        {
            throw new ArgumentOutOfRangeException(nameof(k), "k должен быть неотрицательным.");
        }

        var states = new List<int>(returns.Count);
        foreach (var value in returns)
        {
            if (value > k)
            {
                states.Add(1);
            }
            else if (value < -k)
            {
                states.Add(-1);
            }
            else
            {
                states.Add(0);
            }
        }

        return states;
    }
}

================================================================================

Файл CaForecast.Data/CsvExportService.cs
--------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text;

namespace CaForecast.Data;

public class CsvExportService
{
    private static readonly CultureInfo ExportCulture = CultureInfo.CurrentCulture;

    public void ExportMetrics(string filePath, IEnumerable<MemoryMetricCsvRow> rows, char delimiter = ';')
    {
        if (string.IsNullOrWhiteSpace(filePath))
        {
            throw new ArgumentException("Требуется путь к файлу.", nameof(filePath));
        }

        var sb = new StringBuilder();
        sb.AppendLine(string.Join(delimiter, "Память", "MAE", "MSE", "RMSE", "MAPE"));

        foreach (var row in rows)
        {
            sb.AppendLine(string.Join(
                delimiter,
                row.Memory.ToString(ExportCulture),
                row.Mae.ToString(ExportCulture),
                row.Mse.ToString(ExportCulture),
                row.Rmse.ToString(ExportCulture),
                row.Mape.ToString(ExportCulture)));
        }

        File.WriteAllText(filePath, sb.ToString(), Encoding.UTF8);
    }

    public void ExportForecast(string filePath, IEnumerable<ForecastPointCsvRow> rows, char delimiter = ';')
    {
        if (string.IsNullOrWhiteSpace(filePath))
        {
            throw new ArgumentException("Требуется путь к файлу.", nameof(filePath));
        }

        var sb = new StringBuilder();
        sb.AppendLine(string.Join(delimiter, "Дата", "Изначальная цена", "Прогнозная цена"));

        foreach (var row in rows)
        {
            var dateText = row.Date?.ToString("yyyy-MM-dd", CultureInfo.InvariantCulture) ?? string.Empty;
            sb.AppendLine(string.Join(
                delimiter,
                dateText,
                row.ActualPrice.ToString(ExportCulture),
                row.PredictedPrice.ToString(ExportCulture)));
        }

        File.WriteAllText(filePath, sb.ToString(), Encoding.UTF8);
    }

    public void ExportCombined(
        string filePath,
        IEnumerable<MemoryMetricCsvRow> metricRows,
        IEnumerable<ForecastPointCsvRow> forecastRows,
        int bestMemory,
        char delimiter = ';')
    {
        if (string.IsNullOrWhiteSpace(filePath))
        {
            throw new ArgumentException("Требуется путь к файлу.", nameof(filePath));
        }

        var sb = new StringBuilder();
        sb.AppendLine($"ЛучшаяПамять{delimiter}{bestMemory}");
        sb.AppendLine();
        sb.AppendLine("Метрики");
        sb.AppendLine(string.Join(delimiter, "Память", "MAE", "MSE", "RMSE", "MAPE"));

        foreach (var row in metricRows)
        {
            sb.AppendLine(string.Join(
                delimiter,
                row.Memory.ToString(ExportCulture),
                row.Mae.ToString(ExportCulture),
                row.Mse.ToString(ExportCulture),
                row.Rmse.ToString(ExportCulture),
                row.Mape.ToString(ExportCulture)));
        }

        sb.AppendLine();
        sb.AppendLine("Прогнозная цена");
        sb.AppendLine(string.Join(delimiter, "Дата", "Изначальная цена", "Прогнозная цена"));

        foreach (var row in forecastRows)
        {
            var dateText = row.Date?.ToString("yyyy-MM-dd", CultureInfo.InvariantCulture) ?? string.Empty;
            sb.AppendLine(string.Join(
                delimiter,
                dateText,
                row.ActualPrice.ToString(ExportCulture),
                row.PredictedPrice.ToString(ExportCulture)));
        }

        File.WriteAllText(filePath, sb.ToString(), Encoding.UTF8);
    }
}

================================================================================

Файл CaForecast.Data/CsvImportedData.cs
--------------------------------------------------------------------------------
namespace CaForecast.Data;

public sealed class CsvImportedData
{
    public required IReadOnlyList<double> ClosePrices { get; init; }

    public required IReadOnlyList<DateTime?> Dates { get; init; }
}

================================================================================

Файл CaForecast.Data/CsvImportService.cs
--------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;

namespace CaForecast.Data;

public class CsvImportService
{
    public CsvImportedData Import(string filePath, CsvSettings? settings = null)
    {
        if (string.IsNullOrWhiteSpace(filePath))
        {
            throw new ArgumentException("Требуется путь к файлу.", nameof(filePath));
        }

        if (!File.Exists(filePath))
        {
            throw new FileNotFoundException("CSV-файл не найден.", filePath);
        }

        settings ??= new CsvSettings();

        using var reader = new StreamReader(filePath);
        var sampledLines = new List<(int Number, string Text)>(10);
        var lineNumber = 0;

        while (sampledLines.Count < 10)
        {
            var line = reader.ReadLine();
            if (line is null)
            {
                break;
            }

            lineNumber++;
            if (string.IsNullOrWhiteSpace(line))
            {
                continue;
            }

            sampledLines.Add((lineNumber, line));
        }

        if (sampledLines.Count == 0)
        {
            throw new InvalidOperationException("CSV-файл пуст.");
        }

        var delimiter = settings.Delimiter ?? DetectDelimiter(sampledLines.Select(l => l.Text).ToArray());

        var closeIndex = 0;
        var dateIndex = -1;
        var sampledDataStartIndex = 0;

        if (settings.HasHeader)
        {
            var headerColumns = SplitLine(sampledLines[0].Text, delimiter);
            var parsed = ParseHeader(headerColumns);

            if (parsed.HasExplicitClose)
            {
                closeIndex = parsed.CloseIndex;
                dateIndex = parsed.DateIndex;
            }
            else
            {
                string[] firstDataColumns;
                if (sampledLines.Count > 1)
                {
                    firstDataColumns = SplitLine(sampledLines[1].Text, delimiter);
                }
                else
                {
                    firstDataColumns = ReadNextNonEmptyColumns(reader, delimiter, sampledLines, ref lineNumber);
                }

                if (firstDataColumns.Length >= 2 &&
                    TryParseDouble(GetColumn(firstDataColumns, 1), out _))
                {
                    dateIndex = 0;
                    closeIndex = 1;
                }
                else
                {
                    dateIndex = -1;
                    closeIndex = 0;
                }
            }

            sampledDataStartIndex = 1;
        }
        else
        {
            var firstDataCols = SplitLine(sampledLines[0].Text, delimiter);
            if (firstDataCols.Length > 1)
            {
                dateIndex = 0;
                closeIndex = 1;
            }
        }

        var prices = new List<double>();
        var dates = new List<DateTime?>();

        for (var i = sampledDataStartIndex; i < sampledLines.Count; i++)
        {
            if (IsEndOfDataMarker(sampledLines[i].Text))
            {
                break;
            }

            ParseDataLine(sampledLines[i].Text, sampledLines[i].Number, delimiter, closeIndex, dateIndex, prices, dates);
        }

        while (true)
        {
            var line = reader.ReadLine();
            if (line is null)
            {
                break;
            }

            lineNumber++;
            if (string.IsNullOrWhiteSpace(line))
            {
                continue;
            }

            if (IsEndOfDataMarker(line))
            {
                break;
            }

            ParseDataLine(line, lineNumber, delimiter, closeIndex, dateIndex, prices, dates);
        }

        if (prices.Count < 2)
        {
            throw new InvalidOperationException("Требуется минимум две цены закрытия.");
        }

        return new CsvImportedData
        {
            ClosePrices = prices,
            Dates = dates
        };
    }

    private static void ParseDataLine(
        string line,
        int lineNumber,
        char delimiter,
        int closeIndex,
        int dateIndex,
        ICollection<double> prices,
        ICollection<DateTime?> dates)
    {
        var columns = SplitLine(line, delimiter);
        if (columns.Length == 0)
        {
            return;
        }

        var closeValue = GetColumn(columns, closeIndex);
        if (!TryParseDouble(closeValue, out var close))
        {
            if (IsIgnorableNonDataLine(line, columns, closeIndex, closeValue))
            {
                return;
            }

            throw new FormatException($"Не удалось разобрать значение Close в строке {lineNumber}: '{closeValue}'.");
        }

        prices.Add(close);
        dates.Add(dateIndex >= 0 ? ParseDateSafe(GetColumn(columns, dateIndex)) : null);
    }

    private static string[] ReadNextNonEmptyColumns(
        TextReader reader,
        char delimiter,
        ICollection<(int Number, string Text)> sampledLines,
        ref int lineNumber)
    {
        while (true)
        {
            var line = reader.ReadLine();
            if (line is null)
            {
                return Array.Empty<string>();
            }

            lineNumber++;
            if (string.IsNullOrWhiteSpace(line))
            {
                continue;
            }

            if (IsEndOfDataMarker(line))
            {
                return Array.Empty<string>();
            }

            sampledLines.Add((lineNumber, line));
            return SplitLine(line, delimiter);
        }
    }

    private static bool IsEndOfDataMarker(string line)
    {
        return line.Trim().StartsWith("history.cursor", StringComparison.OrdinalIgnoreCase);
    }

    private static (int CloseIndex, int DateIndex, bool HasExplicitClose) ParseHeader(IReadOnlyList<string> headerColumns)
    {
        var closeIndex = -1;
        var dateIndex = -1;

        for (var i = 0; i < headerColumns.Count; i++)
        {
            var name = headerColumns[i].Trim();
            if (name.Equals("Close", StringComparison.OrdinalIgnoreCase))
            {
                closeIndex = i;
            }
            else if (name.Equals("Date", StringComparison.OrdinalIgnoreCase))
            {
                dateIndex = i;
            }
        }

        if (closeIndex < 0)
        {
            if (headerColumns.Count == 1)
            {
                closeIndex = 0;
            }
            else if (headerColumns.Count >= 2)
            {
                closeIndex = 1;
                dateIndex = 0;
            }
            else
            {
                throw new InvalidOperationException("Заголовок CSV не содержит столбец Close.");
            }
        }

        return (closeIndex, dateIndex, closeIndex >= 0 && headerColumns.Any(h => h.Trim().Equals("Close", StringComparison.OrdinalIgnoreCase)));
    }

    private static char DetectDelimiter(IReadOnlyList<string> lines)
    {
        var commaCount = 0;
        var semicolonCount = 0;

        foreach (var line in lines.Take(10))
        {
            commaCount += line.Count(c => c == ',');
            semicolonCount += line.Count(c => c == ';');
        }

        return semicolonCount > commaCount ? ';' : ',';
    }

    private static string[] SplitLine(string line, char delimiter)
    {
        return line.Split(delimiter);
    }

    private static bool IsIgnorableNonDataLine(string rawLine, IReadOnlyList<string> columns, int closeIndex, string closeValue)
    {
        var text = rawLine.Trim();
        if (string.IsNullOrEmpty(text))
        {
            return true;
        }

        if (text.StartsWith('#'))
        {
            return true;
        }

        if (columns.Count <= closeIndex || string.IsNullOrWhiteSpace(closeValue))
        {
            return !text.Any(char.IsDigit);
        }

        return false;
    }

    private static string GetColumn(IReadOnlyList<string> columns, int index)
    {
        if (index < 0 || index >= columns.Count)
        {
            return string.Empty;
        }

        return columns[index].Trim();
    }

    private static bool TryParseDouble(string input, out double value)
    {
        if (double.TryParse(input, NumberStyles.Float, CultureInfo.InvariantCulture, out value))
        {
            return true;
        }

        return double.TryParse(input, NumberStyles.Float, CultureInfo.CurrentCulture, out value);
    }

    private static DateTime? ParseDateSafe(string input)
    {
        if (string.IsNullOrWhiteSpace(input))
        {
            return null;
        }

        if (DateTime.TryParse(input, CultureInfo.InvariantCulture, DateTimeStyles.None, out var invariant))
        {
            return invariant;
        }

        if (DateTime.TryParse(input, CultureInfo.CurrentCulture, DateTimeStyles.None, out var current))
        {
            return current;
        }

        return null;
    }
}

================================================================================

Файл CaForecast.Data/CsvSettings.cs
--------------------------------------------------------------------------------
namespace CaForecast.Data;

public class CsvSettings
{
    public char? Delimiter { get; set; }

    public bool HasHeader { get; set; } = true;
}

================================================================================

Файл CaForecast.Data/ForecastPointCsvRow.cs
--------------------------------------------------------------------------------
namespace CaForecast.Data;

public sealed class ForecastPointCsvRow
{
    public required DateTime? Date { get; init; }

    public required double ActualPrice { get; init; }

    public required double PredictedPrice { get; init; }
}

================================================================================

Файл CaForecast.Data/MemoryMetricCsvRow.cs
--------------------------------------------------------------------------------
namespace CaForecast.Data;

public sealed class MemoryMetricCsvRow
{
    public required int Memory { get; init; }

    public required double Mae { get; init; }

    public required double Mse { get; init; }

    public required double Rmse { get; init; }

    public required double Mape { get; init; }
}

================================================================================

Файл CaForecast.Data/MoexIssService.cs
--------------------------------------------------------------------------------
using System.Globalization;
using System.Net;
using System.Net.Http;
using System.Text.Json;

namespace CaForecast.Data;

public class MoexIssService
{
    private const int MaxRangeDays = 365 * 30;

    private static readonly HttpClient HttpClient = new()
    {
        Timeout = TimeSpan.FromSeconds(20)
    };

    public CsvImportedData ImportDailyHistory(string secId, DateTime from, DateTime till, string boardId = "TQBR")
    {
        if (string.IsNullOrWhiteSpace(secId))
        {
            throw new ArgumentException("Требуется тикер бумаги.", nameof(secId));
        }

        if (string.IsNullOrWhiteSpace(boardId))
        {
            throw new ArgumentException("Требуется код режима торгов.", nameof(boardId));
        }

        if (till < from)
        {
            throw new ArgumentException("Дата окончания периода должна быть не раньше даты начала.");
        }

        var rangeDays = (till.Date - from.Date).TotalDays;
        if (rangeDays > MaxRangeDays)
        {
            throw new ArgumentException("Слишком большой диапазон дат. Выберите период не более 30 лет.");
        }

        var prices = new List<double>();
        var dates = new List<DateTime?>();
        var start = 0;

        while (true)
        {
            var url = BuildHistoryUrl(secId, boardId, from, till, start);

            HttpResponseMessage response;
            try
            {
                response = HttpClient.GetAsync(url).GetAwaiter().GetResult();
            }
            catch (TaskCanceledException ex)
            {
                throw new TimeoutException(
                    "MOEX ISS не ответил вовремя. Попробуйте сузить диапазон дат или повторить позже.",
                    ex);
            }
            catch (HttpRequestException ex)
            {
                throw new InvalidOperationException(
                    "Не удалось подключиться к MOEX ISS. Проверьте подключение к интернету.",
                    ex);
            }

            using (response)
            {
                if (response.StatusCode is HttpStatusCode.NotFound or HttpStatusCode.BadRequest)
                {
                    throw new InvalidOperationException(
                        $"MOEX ISS не нашел данные для тикера '{secId}' и режима торгов '{boardId}'. Проверьте параметры.");
                }

                if (!response.IsSuccessStatusCode)
                {
                    throw new InvalidOperationException(
                        $"MOEX ISS вернул ошибку HTTP {(int)response.StatusCode} ({response.StatusCode}).");
                }

                using var stream = response.Content.ReadAsStream();
                using var document = JsonDocument.Parse(stream);

                if (!document.RootElement.TryGetProperty("history", out var historyElement))
                {
                    throw new InvalidOperationException("Ответ MOEX ISS не содержит секцию history.");
                }

                var dateIndex = -1;
                var closeIndex = -1;
                if (historyElement.TryGetProperty("columns", out var columnsElement))
                {
                    var index = 0;
                    foreach (var column in columnsElement.EnumerateArray())
                    {
                        var name = column.GetString() ?? string.Empty;
                        if (name.Equals("TRADEDATE", StringComparison.OrdinalIgnoreCase))
                        {
                            dateIndex = index;
                        }
                        else if (name.Equals("CLOSE", StringComparison.OrdinalIgnoreCase))
                        {
                            closeIndex = index;
                        }

                        index++;
                    }
                }

                if (dateIndex < 0 || closeIndex < 0)
                {
                    throw new InvalidOperationException("В ответе MOEX ISS не найдены поля TRADEDATE/CLOSE.");
                }

                if (!historyElement.TryGetProperty("data", out var dataElement))
                {
                    throw new InvalidOperationException("Ответ MOEX ISS не содержит данные history.data.");
                }

                var pageRows = 0;
                foreach (var row in dataElement.EnumerateArray())
                {
                    pageRows++;
                    if (row.ValueKind != JsonValueKind.Array)
                    {
                        continue;
                    }

                    var rowValues = row.EnumerateArray().ToArray();
                    if (rowValues.Length <= Math.Max(dateIndex, closeIndex))
                    {
                        continue;
                    }

                    var closeValue = rowValues[closeIndex];
                    var dateValue = rowValues[dateIndex];

                    if (!TryParseDouble(closeValue, out var close))
                    {
                        continue;
                    }

                    if (!TryParseDate(dateValue, out var tradeDate))
                    {
                        continue;
                    }

                    prices.Add(close);
                    dates.Add(tradeDate);
                }

                if (pageRows == 0)
                {
                    break;
                }

                start += pageRows;
            }
        }

        if (prices.Count < 2)
        {
            throw new InvalidOperationException(
                $"По выбранным параметрам найдено недостаточно данных (меньше двух цен). Проверьте тикер '{secId}', режим торгов '{boardId}' и диапазон дат.");
        }

        return new CsvImportedData
        {
            ClosePrices = prices,
            Dates = dates
        };
    }

    private static string BuildHistoryUrl(string secId, string boardId, DateTime from, DateTime till, int start)
    {
        return
            $"https://iss.moex.com/iss/history/engines/stock/markets/shares/boards/{Uri.EscapeDataString(boardId)}/securities/{Uri.EscapeDataString(secId)}.json" +
            $"?from={from:yyyy-MM-dd}&till={till:yyyy-MM-dd}&start={start}&iss.meta=off";
    }

    private static bool TryParseDate(JsonElement element, out DateTime value)
    {
        if (element.ValueKind == JsonValueKind.String)
        {
            var raw = element.GetString();
            if (!string.IsNullOrWhiteSpace(raw))
            {
                if (DateTime.TryParseExact(raw, "yyyy-MM-dd", CultureInfo.InvariantCulture, DateTimeStyles.None, out value))
                {
                    return true;
                }

                if (DateTime.TryParse(raw, CultureInfo.InvariantCulture, DateTimeStyles.None, out value))
                {
                    return true;
                }
            }
        }

        value = default;
        return false;
    }

    private static bool TryParseDouble(JsonElement element, out double value)
    {
        if (element.ValueKind == JsonValueKind.Number && element.TryGetDouble(out value))
        {
            return true;
        }

        if (element.ValueKind == JsonValueKind.String)
        {
            var raw = element.GetString();
            if (!string.IsNullOrWhiteSpace(raw))
            {
                if (double.TryParse(raw, NumberStyles.Float, CultureInfo.InvariantCulture, out value))
                {
                    return true;
                }

                if (double.TryParse(raw, NumberStyles.Float, CultureInfo.CurrentCulture, out value))
                {
                    return true;
                }
            }
        }

        value = default;
        return false;
    }
}

================================================================================

Файл CaForecast.WpfApp/App.xaml
--------------------------------------------------------------------------------
<Application x:Class="CaForecast.WpfApp.App"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:local="clr-namespace:CaForecast.WpfApp"
             StartupUri="MainWindow.xaml">
    <Application.Resources>
         
    </Application.Resources>
</Application>

================================================================================

Файл CaForecast.WpfApp/App.xaml.cs
--------------------------------------------------------------------------------
using System.Configuration;
using System.Data;
using System.Windows;

namespace CaForecast.WpfApp;

/// <summary>
/// Interaction logic for App.xaml
/// </summary>
public partial class App : Application
{
}

================================================================================

Файл CaForecast.WpfApp/AssemblyInfo.cs
--------------------------------------------------------------------------------
using System.Windows;

[assembly:ThemeInfo(
    ResourceDictionaryLocation.None,            //where theme specific resource dictionaries are located
                                                //(used if a resource is not found in the page,
                                                // or application resource dictionaries)
    ResourceDictionaryLocation.SourceAssembly   //where the generic resource dictionary is located
                                                //(used if a resource is not found in the page,
                                                // app, or any theme specific resource dictionaries)
)]

================================================================================

Файл CaForecast.WpfApp/BestMemoryErrorRow.cs
--------------------------------------------------------------------------------
namespace CaForecast.WpfApp;

public class BestMemoryErrorRow
{
    public int Memory { get; init; }

    public double MaePercent { get; init; }

    public double MsePercent { get; init; }

    public double RmsePercent { get; init; }

    public double MapePercent { get; init; }
}

================================================================================

Файл CaForecast.WpfApp/MainViewModel.cs
--------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Globalization;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using CaForecast.Core;
using CaForecast.Data;
using Microsoft.Win32;
using OxyPlot;
using OxyPlot.Axes;
using OxyPlot.Legends;
using OxyPlot.Series;

namespace CaForecast.WpfApp;

public class MainViewModel : INotifyPropertyChanged
{
    private readonly CsvImportService _csvImportService = new();
    private readonly MoexIssService _moexIssService = new();
    private readonly CsvExportService _csvExportService = new();
    private readonly ReturnCalculator _returnCalculator = new();
    private readonly ThreeColorEncoder _encoder = new();
    private readonly CaRuleTrainer _trainer = new();
    private readonly CaForecaster _forecaster = new();
    private readonly MetricsService _metricsService = new();

    private CsvImportedData? _sourceData;
    private CsvImportedData? _loadedData;
    private ForecastResult? _bestResult;
    private List<DateTime?> _bestDates = new();

    private string _selectedFilePath = "Данные не загружены";
    private bool _isApiInputsVisible;
    private string _secIdText = "SBER";
    private string _boardIdText = "TQBR";
    private string _fromDateText = DateTime.Today.AddYears(-1).ToString("yyyy-MM-dd", CultureInfo.InvariantCulture);
    private string _tillDateText = DateTime.Today.ToString("yyyy-MM-dd", CultureInfo.InvariantCulture);
    private string _trainPercentText = "70";
    private string _kText = "0.002";
    private string _alphaText = "1.0";
    private string _maxMemoryMText = "8";
    private string _maxPlotPointsText = "3000";
    private string _statusMessage = "Загрузите CSV или MOEX ISS.";
    private PlotModel _plotModel = BuildEmptyPlotModel();
    private bool _isInternalUpdate;
    private bool _isBusy;
    private readonly CancellationTokenSource _shutdownCts = new();

    public MainViewModel()
    {
        LoadCsvCommand = new RelayCommand(LoadCsv, () => !_isBusy);
        ShowMoexInputsCommand = new RelayCommand(() => IsApiInputsVisible = true);
        HideMoexInputsCommand = new RelayCommand(() => IsApiInputsVisible = false);
        LoadMoexCommand = new RelayCommand(() => _ = LoadMoexAsync(), () => !_isBusy);
        RunCommand = new RelayCommand(() => _ = RunAsync(showErrors: true), () => _loadedData is not null && !_isBusy);
        ExportResultsCommand = new RelayCommand(ExportResults, () => _bestResult is not null && !_isBusy);
    }

    public event PropertyChangedEventHandler? PropertyChanged;

    public RelayCommand LoadCsvCommand { get; }

    public RelayCommand ShowMoexInputsCommand { get; }

    public RelayCommand HideMoexInputsCommand { get; }

    public RelayCommand LoadMoexCommand { get; }

    public RelayCommand RunCommand { get; }

    public RelayCommand ExportResultsCommand { get; }

    public ObservableCollection<MemoryErrorRow> ErrorRows { get; } = new();

    public ObservableCollection<BestMemoryErrorRow> BestRows { get; } = new();

    public string SelectedFilePath
    {
        get => _selectedFilePath;
        set => SetField(ref _selectedFilePath, value);
    }

    public bool IsApiInputsVisible
    {
        get => _isApiInputsVisible;
        set => SetField(ref _isApiInputsVisible, value);
    }

    public string SecIdText
    {
        get => _secIdText;
        set => SetField(ref _secIdText, value);
    }

    public string BoardIdText
    {
        get => _boardIdText;
        set => SetField(ref _boardIdText, value);
    }

    public string FromDateText
    {
        get => _fromDateText;
        set
        {
            if (SetField(ref _fromDateText, value))
            {
                AutoRefresh();
            }
        }
    }

    public string TillDateText
    {
        get => _tillDateText;
        set
        {
            if (SetField(ref _tillDateText, value))
            {
                AutoRefresh();
            }
        }
    }

    public string TrainPercentText
    {
        get => _trainPercentText;
        set
        {
            if (SetField(ref _trainPercentText, value))
            {
                AutoRefresh();
            }
        }
    }

    public string KText
    {
        get => _kText;
        set
        {
            if (SetField(ref _kText, value))
            {
                AutoRefresh();
            }
        }
    }

    public string AlphaText
    {
        get => _alphaText;
        set
        {
            if (SetField(ref _alphaText, value))
            {
                AutoRefresh();
            }
        }
    }

    public string MaxMemoryMText
    {
        get => _maxMemoryMText;
        set
        {
            if (SetField(ref _maxMemoryMText, value))
            {
                AutoRefresh();
            }
        }
    }

    public string MaxPlotPointsText
    {
        get => _maxPlotPointsText;
        set
        {
            if (SetField(ref _maxPlotPointsText, value))
            {
                AutoRefresh();
            }
        }
    }

    public string StatusMessage
    {
        get => _statusMessage;
        set => SetField(ref _statusMessage, value);
    }

    public bool IsBusy
    {
        get => _isBusy;
        private set => SetField(ref _isBusy, value);
    }

    public PlotModel PlotModel
    {
        get => _plotModel;
        set => SetField(ref _plotModel, value);
    }

    public IPlotController LockedPlotController { get; } = BuildLockedPlotController();

    public void CancelBackgroundOperations()
    {
        _shutdownCts.Cancel();
    }

    private void LoadCsv()
    {
        var dialog = new OpenFileDialog
        {
            Filter = "CSV-файлы (*.csv)|*.csv|Все файлы (*.*)|*.*"
        };

        if (dialog.ShowDialog() != true)
        {
            return;
        }

        try
        {
            _sourceData = _csvImportService.Import(dialog.FileName, new CsvSettings());
            SelectedFilePath = dialog.FileName;
            IsApiInputsVisible = false;
            InitializeDateRangeFromData(_sourceData);
            if (!TryApplyDateFilter(showErrors: true))
            {
                return;
            }

            _ = RunAsync(showErrors: true);
        }
        catch (Exception ex)
        {
            StatusMessage = $"Ошибка загрузки CSV: {ex.Message}";
        }
    }

    private async Task LoadMoexAsync()
    {
        if (_isBusy)
        {
            return;
        }

        SetBusy(true);
        try
        {
            if (!TryParseDate(FromDateText, out var fromDate))
            {
                throw new InvalidOperationException("Дата \"С\" должна быть в формате yyyy-MM-dd.");
            }

            if (!TryParseDate(TillDateText, out var tillDate))
            {
                throw new InvalidOperationException("Дата \"По\" должна быть в формате yyyy-MM-dd.");
            }

            var secId = (SecIdText ?? string.Empty).Trim().ToUpperInvariant();
            var boardId = (BoardIdText ?? string.Empty).Trim().ToUpperInvariant();
            if (string.IsNullOrWhiteSpace(secId))
            {
                throw new InvalidOperationException("Укажите тикер бумаги (например, SBER).");
            }

            if (string.IsNullOrWhiteSpace(boardId))
            {
                throw new InvalidOperationException("Укажите режим торгов (например, TQBR).");
            }

            StatusMessage = "Загрузка MOEX ISS...";
            var importedData = await Task.Run(
                () => _moexIssService.ImportDailyHistory(secId, fromDate, tillDate, boardId),
                _shutdownCts.Token);

            if (_shutdownCts.IsCancellationRequested)
            {
                return;
            }

            _sourceData = importedData;
            SelectedFilePath = $"MOEX ISS: {boardId}/{secId}";
            IsApiInputsVisible = false;
            if (!TryApplyDateFilter(showErrors: true))
            {
                return;
            }

            await RunAsync(showErrors: true, manageBusy: false);
        }
        catch (OperationCanceledException)
        {
            StatusMessage = "Операция отменена.";
        }
        catch (Exception ex)
        {
            StatusMessage = $"Ошибка загрузки MOEX ISS: {ex.Message}";
        }
        finally
        {
            SetBusy(false);
        }
    }

    private async Task RunAsync(bool showErrors, bool manageBusy = true)
    {
        if (_isBusy && manageBusy)
        {
            return;
        }

        if (manageBusy)
        {
            SetBusy(true);
        }

        if (!TryApplyDateFilter(showErrors: true))
        {
            if (manageBusy)
            {
                SetBusy(false);
            }

            return;
        }

        if (_loadedData is null)
        {
            if (showErrors)
            {
                StatusMessage = "Сначала загрузите данные.";
            }

            if (manageBusy)
            {
                SetBusy(false);
            }

            return;
        }

        try
        {
            if (!TryParseDouble(TrainPercentText, out var trainPercent) || trainPercent <= 0 || trainPercent >= 100)
            {
                throw new InvalidOperationException("Параметр \"Доля выборки, %\" должен быть в диапазоне (0, 100).");
            }

            if (!TryParseDouble(KText, out var k) || k < 0)
            {
                throw new InvalidOperationException("k должен быть неотрицательным.");
            }

            if (!TryParseDouble(AlphaText, out var alpha) || alpha < 0)
            {
                throw new InvalidOperationException("alpha должен быть неотрицательным.");
            }

            if (!int.TryParse(MaxMemoryMText, NumberStyles.Integer, CultureInfo.InvariantCulture, out var maxMemoryM) ||
                maxMemoryM < 1)
            {
                throw new InvalidOperationException("MaxMemoryM должен быть целым числом >= 1.");
            }

            if (!int.TryParse(MaxPlotPointsText, NumberStyles.Integer, CultureInfo.InvariantCulture, out var maxPlotPoints) ||
                maxPlotPoints < 100)
            {
                throw new InvalidOperationException("MaxPlotPoints должен быть целым числом >= 100.");
            }

            var loadedData = _loadedData;
            var computed = await Task.Run(
                () => ComputeForecast(loadedData, trainPercent, k, alpha, maxMemoryM, maxPlotPoints, _shutdownCts.Token),
                _shutdownCts.Token);

            if (_shutdownCts.IsCancellationRequested)
            {
                return;
            }

            _bestResult = computed.BestResult;
            ErrorRows.Clear();
            foreach (var row in computed.ErrorRows)
            {
                ErrorRows.Add(row);
            }

            BestRows.Clear();
            BestRows.Add(computed.BestRow);
            _bestDates = computed.BestDates;
            PlotModel = computed.PlotModel;

            StatusMessage =
                $"Расчет обновлен. Лучшее m = {computed.BestResult.Memory}, MAE = {FormatPercent(computed.BestMaePercent)}, MSE = {FormatPercent(computed.BestMsePercent)}, RMSE = {FormatPercent(computed.BestRmsePercent)}, MAPE = {computed.BestResult.MapePercent:F2}%.";
            ExportResultsCommand.RaiseCanExecuteChanged();
        }
        catch (OperationCanceledException)
        {
            StatusMessage = "Операция отменена.";
        }
        catch (Exception ex)
        {
            if (showErrors)
            {
                StatusMessage = $"Ошибка расчета: {ex.Message}";
            }
        }
        finally
        {
            if (manageBusy)
            {
                SetBusy(false);
            }
        }
    }

    private void AutoRefresh()
    {
        if (_isInternalUpdate || _sourceData is null || _isBusy)
        {
            return;
        }

        _ = RunAsync(showErrors: false);
    }

    private bool TryApplyDateFilter(bool showErrors)
    {
        if (_sourceData is null)
        {
            return false;
        }

        var sourcePrices = _sourceData.ClosePrices;
        var sourceDates = _sourceData.Dates;
        if (sourcePrices.Count != sourceDates.Count)
        {
            if (showErrors)
            {
                StatusMessage = "Ошибка данных: количество дат не совпадает с количеством цен.";
            }

            return false;
        }

        if (!TryParseDate(FromDateText, out var fromDate) || !TryParseDate(TillDateText, out var tillDate))
        {
            if (showErrors)
            {
                StatusMessage = "Укажите диапазон дат в формате yyyy-MM-dd.";
            }

            return false;
        }

        if (tillDate < fromDate)
        {
            if (showErrors)
            {
                StatusMessage = "Дата \"По\" должна быть не раньше даты \"С\".";
            }

            return false;
        }

        var filteredPrices = new List<double>(sourcePrices.Count);
        var filteredDates = new List<DateTime?>(sourceDates.Count);
        var hasDateValues = sourceDates.Any(d => d.HasValue);

        if (hasDateValues)
        {
            for (var i = 0; i < sourcePrices.Count; i++)
            {
                var date = sourceDates[i];
                if (!date.HasValue)
                {
                    continue;
                }

                if (date.Value.Date < fromDate.Date || date.Value.Date > tillDate.Date)
                {
                    continue;
                }

                filteredPrices.Add(sourcePrices[i]);
                filteredDates.Add(date.Value.Date);
            }
        }
        else
        {
            filteredPrices.AddRange(sourcePrices);
            filteredDates.AddRange(sourceDates);
        }

        if (filteredPrices.Count < 2)
        {
            ResetCalculatedState();
            if (showErrors)
            {
                StatusMessage = "После фильтрации по датам осталось меньше двух цен.";
            }

            return false;
        }

        _loadedData = new CsvImportedData
        {
            ClosePrices = filteredPrices,
            Dates = filteredDates
        };

        RunCommand.RaiseCanExecuteChanged();
        return true;
    }

    private RunComputationResult ComputeForecast(
        CsvImportedData loadedData,
        double trainPercent,
        double k,
        double alpha,
        int maxMemoryM,
        int maxPlotPoints,
        CancellationToken cancellationToken)
    {
        var prices = loadedData.ClosePrices;
        var returns = _returnCalculator.CalculateLogReturns(prices);
        var encodedStates = _encoder.Encode(returns, k);

        var trainReturnsCount = (int)Math.Round(returns.Count * (trainPercent / 100.0), MidpointRounding.AwayFromZero);
        trainReturnsCount = Math.Max(2, Math.Min(trainReturnsCount, returns.Count - 1));

        var errorRows = new List<MemoryErrorRow>();
        ForecastResult? bestResult = null;
        for (var m = 1; m <= maxMemoryM; m++)
        {
            cancellationToken.ThrowIfCancellationRequested();
            if (m >= trainReturnsCount)
            {
                break;
            }

            var result = _forecaster.Forecast(
                prices,
                returns,
                encodedStates,
                trainReturnsCount,
                m,
                alpha,
                _trainer,
                _metricsService);

            errorRows.Add(new MemoryErrorRow
            {
                Memory = result.Memory,
                Mae = result.Mae,
                Mse = result.Mse,
                Rmse = result.Rmse,
                Mape = result.MapePercent / 100.0
            });

            if (bestResult is null || result.Rmse < bestResult.Rmse)
            {
                bestResult = result;
            }
        }

        if (bestResult is null)
        {
            throw new InvalidOperationException("Не удалось построить модель. Проверьте параметры \"Доля выборки, %\" и \"max(m)\".");
        }

        var bestMaePercent = CalculateRelativePercent(bestResult.Mae, bestResult.ActualPrices);
        var bestMsePercent = CalculateRelativeSquaredPercent(bestResult.Mse, bestResult.ActualPrices);
        var bestRmsePercent = CalculateRelativePercent(bestResult.Rmse, bestResult.ActualPrices);
        var bestRow = new BestMemoryErrorRow
        {
            Memory = bestResult.Memory,
            MaePercent = bestMaePercent,
            MsePercent = bestMsePercent,
            RmsePercent = bestRmsePercent,
            MapePercent = bestResult.MapePercent
        };

        var bestDates = BuildBestDates(loadedData.Dates, bestResult.TrainReturnsCount, bestResult.ActualPrices.Count);
        var plotModel = BuildPlot(bestResult, loadedData.ClosePrices, loadedData.Dates, maxPlotPoints);

        return new RunComputationResult
        {
            BestResult = bestResult,
            ErrorRows = errorRows,
            BestRow = bestRow,
            BestDates = bestDates,
            PlotModel = plotModel,
            BestMaePercent = bestMaePercent,
            BestMsePercent = bestMsePercent,
            BestRmsePercent = bestRmsePercent
        };
    }

    private void ResetCalculatedState()
    {
        _bestResult = null;
        _bestDates = new List<DateTime?>();
        ErrorRows.Clear();
        BestRows.Clear();
        PlotModel = BuildEmptyPlotModel();
        ExportResultsCommand.RaiseCanExecuteChanged();
    }

    private void InitializeDateRangeFromData(CsvImportedData data)
    {
        var dateBounds = data.Dates
            .Where(d => d.HasValue)
            .Select(d => d!.Value.Date)
            .OrderBy(d => d)
            .ToArray();

        if (dateBounds.Length == 0)
        {
            return;
        }

        _isInternalUpdate = true;
        try
        {
            FromDateText = dateBounds.First().ToString("yyyy-MM-dd", CultureInfo.InvariantCulture);
            TillDateText = dateBounds.Last().ToString("yyyy-MM-dd", CultureInfo.InvariantCulture);
        }
        finally
        {
            _isInternalUpdate = false;
        }
    }

    private void ExportResults()
    {
        if (_bestResult is null)
        {
            StatusMessage = "Нет результатов для экспорта.";
            return;
        }

        var dialog = new SaveFileDialog
        {
            Filter = "CSV-файлы (*.csv)|*.csv",
            FileName = "результаты_прогноза.csv"
        };

        if (dialog.ShowDialog() != true)
        {
            return;
        }

        try
        {
            var metricRows = ErrorRows.Select(row => new MemoryMetricCsvRow
            {
                Memory = row.Memory,
                Mae = row.Mae,
                Mse = row.Mse,
                Rmse = row.Rmse,
                Mape = row.Mape
            }).ToArray();

            var forecastRows = _bestResult.ActualPrices
                .Select((actualPrice, i) => new ForecastPointCsvRow
                {
                    Date = i < _bestDates.Count ? _bestDates[i] : null,
                    ActualPrice = actualPrice,
                    PredictedPrice = _bestResult.PredictedPrices[i]
                })
                .ToArray();

            _csvExportService.ExportCombined(dialog.FileName, metricRows, forecastRows, _bestResult.Memory);
            StatusMessage = $"Результаты экспортированы: {dialog.FileName}";
        }
        catch (Exception ex)
        {
            StatusMessage = $"Ошибка экспорта: {ex.Message}";
        }
    }

    private static bool TryParseDouble(string text, out double value)
    {
        if (double.TryParse(text, NumberStyles.Float, CultureInfo.InvariantCulture, out value))
        {
            return true;
        }

        return double.TryParse(text, NumberStyles.Float, CultureInfo.CurrentCulture, out value);
    }

    private static bool TryParseDate(string text, out DateTime value)
    {
        if (DateTime.TryParseExact(text, "yyyy-MM-dd", CultureInfo.InvariantCulture, DateTimeStyles.None, out value))
        {
            return true;
        }

        return DateTime.TryParse(text, CultureInfo.CurrentCulture, DateTimeStyles.None, out value);
    }

    private static double CalculateRelativePercent(double metricValue, IReadOnlyList<double> actualPrices)
    {
        if (actualPrices.Count == 0)
        {
            return double.NaN;
        }

        var meanAbsActual = actualPrices.Select(Math.Abs).Average();
        if (meanAbsActual < 1e-12)
        {
            return double.NaN;
        }

        return (metricValue / meanAbsActual) * 100.0;
    }

    private static double CalculateRelativeSquaredPercent(double metricValue, IReadOnlyList<double> actualPrices)
    {
        if (actualPrices.Count == 0)
        {
            return double.NaN;
        }

        var meanSquareActual = actualPrices.Select(v => v * v).Average();
        if (meanSquareActual < 1e-12)
        {
            return double.NaN;
        }

        return (metricValue / meanSquareActual) * 100.0;
    }

    private static string FormatPercent(double value)
    {
        return double.IsNaN(value) || double.IsInfinity(value) ? "н/д" : $"{value:F2}%";
    }

    private void SetBusy(bool value)
    {
        if (IsBusy == value)
        {
            return;
        }

        IsBusy = value;
        LoadCsvCommand.RaiseCanExecuteChanged();
        LoadMoexCommand.RaiseCanExecuteChanged();
        RunCommand.RaiseCanExecuteChanged();
        ExportResultsCommand.RaiseCanExecuteChanged();
    }

    private static List<DateTime?> BuildBestDates(IReadOnlyList<DateTime?> allDates, int trainReturnsCount, int forecastCount)
    {
        var result = new List<DateTime?>(forecastCount);
        for (var i = 0; i < forecastCount; i++)
        {
            var dateIndex = trainReturnsCount + 1 + i;
            result.Add(dateIndex >= 0 && dateIndex < allDates.Count ? allDates[dateIndex] : null);
        }

        return result;
    }

    private static PlotModel BuildEmptyPlotModel()
    {
        var model = new PlotModel { Title = "Прогноз цены" };
        model.Axes.Add(new LinearAxis { Position = AxisPosition.Bottom, Title = "Дата" });
        model.Axes.Add(new LinearAxis { Position = AxisPosition.Left, Title = "Цена" });
        return model;
    }

    private static PlotModel BuildPlot(
        ForecastResult bestResult,
        IReadOnlyList<double> allPrices,
        IReadOnlyList<DateTime?> allCsvDates,
        int maxPlotPoints)
    {
        var model = new PlotModel
        {
            Title = $"Прогноз цены (лучшее m = {bestResult.Memory})",
            IsLegendVisible = true
        };
        model.Legends.Add(new Legend
        {
            LegendPosition = LegendPosition.RightTop,
            LegendPlacement = LegendPlacement.Outside
        });

        var csvDateBounds = allCsvDates
            .Where(d => d.HasValue)
            .Select(d => d!.Value)
            .OrderBy(d => d)
            .ToArray();

        var hasCsvDates = csvDateBounds.Length > 0;
        var useDateAxis = hasCsvDates;

        var yValues = allPrices
            .Concat(bestResult.PredictedPrices)
            .Where(v => !double.IsNaN(v) && !double.IsInfinity(v))
            .ToArray();

        if (yValues.Length == 0)
        {
            return BuildEmptyPlotModel();
        }

        var minY = yValues.Min();
        var maxY = yValues.Max();
        if (Math.Abs(maxY - minY) < 1e-12)
        {
            var delta = Math.Abs(minY) > 1e-12 ? Math.Abs(minY) * 0.01 : 1.0;
            minY -= delta;
            maxY += delta;
        }

        if (useDateAxis)
        {
            var minDate = csvDateBounds.First();
            var maxDate = csvDateBounds.Last();
            if (maxDate <= minDate)
            {
                maxDate = minDate.AddDays(1);
            }

            var totalDays = Math.Max(1.0, (maxDate - minDate).TotalDays);
            var majorStepDays = Math.Max(1.0, Math.Ceiling(totalDays / 8.0));

            model.Axes.Add(new DateTimeAxis
            {
                Position = AxisPosition.Bottom,
                Title = "Дата",
                StringFormat = "yyyy-MM-dd",
                IntervalType = DateTimeIntervalType.Days,
                MinorIntervalType = DateTimeIntervalType.Days,
                MajorStep = majorStepDays,
                MinorStep = Math.Max(1.0, Math.Floor(majorStepDays / 2.0)),
                Angle = 45,
                MinimumPadding = 0,
                MaximumPadding = 0,
                Minimum = DateTimeAxis.ToDouble(minDate),
                Maximum = DateTimeAxis.ToDouble(maxDate),
                AbsoluteMinimum = DateTimeAxis.ToDouble(minDate),
                AbsoluteMaximum = DateTimeAxis.ToDouble(maxDate),
                IsPanEnabled = false,
                IsZoomEnabled = false
            });
        }
        else
        {
            var maxX = Math.Max(1, bestResult.ActualPrices.Count - 1);
            model.Axes.Add(new LinearAxis
            {
                Position = AxisPosition.Bottom,
                Title = "Дата",
                MinimumPadding = 0,
                MaximumPadding = 0,
                Minimum = 0,
                Maximum = maxX,
                AbsoluteMinimum = 0,
                AbsoluteMaximum = maxX,
                IsPanEnabled = false,
                IsZoomEnabled = false
            });
        }

        model.Axes.Add(new LinearAxis
        {
            Position = AxisPosition.Left,
            Title = "Цена",
            MinimumPadding = 0,
            MaximumPadding = 0,
            Minimum = minY,
            Maximum = maxY,
            AbsoluteMinimum = minY,
            AbsoluteMaximum = maxY,
            IsPanEnabled = false,
            IsZoomEnabled = false
        });

        var actualSeries = new LineSeries { Title = "Изначальная цена", StrokeThickness = 2 };
        var predictedSeries = new LineSeries { Title = "Прогнозная цена", StrokeThickness = 2 };
        var actualPlotIndices = BuildPlotIndices(allPrices.Count, maxPlotPoints);
        var forecastStartIndex = bestResult.TrainReturnsCount + 1;
        var predictedPlotIndices = BuildPlotIndices(bestResult.PredictedPrices.Count, maxPlotPoints);

        foreach (var i in actualPlotIndices)
        {
            if (i < 0 || i >= allPrices.Count)
            {
                continue;
            }

            if (double.IsNaN(allPrices[i]) || double.IsInfinity(allPrices[i]))
            {
                continue;
            }

            var x = (double)i;
            if (useDateAxis)
            {
                DateTime pointDate;
                if (i < allCsvDates.Count && allCsvDates[i].HasValue)
                {
                    pointDate = allCsvDates[i]!.Value;
                }
                else
                {
                    var minDate = csvDateBounds.First();
                    var maxDate = csvDateBounds.Last();
                    var totalDays = Math.Max(1.0, (maxDate - minDate).TotalDays);
                    var ratio = allPrices.Count > 1
                        ? (double)i / (allPrices.Count - 1)
                        : 0.0;
                    pointDate = minDate.AddDays(totalDays * ratio);
                }

                x = DateTimeAxis.ToDouble(pointDate);
            }

            actualSeries.Points.Add(new DataPoint(x, allPrices[i]));
        }

        foreach (var localIndex in predictedPlotIndices)
        {
            if (localIndex < 0 || localIndex >= bestResult.PredictedPrices.Count)
            {
                continue;
            }

            var predictedPrice = bestResult.PredictedPrices[localIndex];
            if (double.IsNaN(predictedPrice) || double.IsInfinity(predictedPrice))
            {
                continue;
            }

            var globalIndex = forecastStartIndex + localIndex;
            var x = (double)globalIndex;
            if (useDateAxis)
            {
                DateTime pointDate;
                if (globalIndex < allCsvDates.Count && allCsvDates[globalIndex].HasValue)
                {
                    pointDate = allCsvDates[globalIndex]!.Value;
                }
                else
                {
                    var minDate = csvDateBounds.First();
                    var maxDate = csvDateBounds.Last();
                    var totalDays = Math.Max(1.0, (maxDate - minDate).TotalDays);
                    var ratio = allPrices.Count > 1
                        ? (double)Math.Min(globalIndex, allPrices.Count - 1) / (allPrices.Count - 1)
                        : 0.0;
                    pointDate = minDate.AddDays(totalDays * ratio);
                }

                x = DateTimeAxis.ToDouble(pointDate);
            }

            predictedSeries.Points.Add(new DataPoint(x, predictedPrice));
        }

        model.Series.Add(actualSeries);
        model.Series.Add(predictedSeries);
        return model;
    }

    private static IPlotController BuildLockedPlotController()
    {
        var controller = new PlotController();
        controller.UnbindAll();
        return controller;
    }

    private static IReadOnlyList<int> BuildPlotIndices(int totalCount, int maxPoints)
    {
        if (totalCount <= 0)
        {
            return Array.Empty<int>();
        }

        if (totalCount <= maxPoints || maxPoints < 2)
        {
            return Enumerable.Range(0, totalCount).ToArray();
        }

        var result = new List<int>(maxPoints);
        var step = (double)(totalCount - 1) / (maxPoints - 1);
        var previous = -1;

        for (var i = 0; i < maxPoints; i++)
        {
            var index = (int)Math.Round(i * step, MidpointRounding.AwayFromZero);
            if (index >= totalCount)
            {
                index = totalCount - 1;
            }

            if (index == previous)
            {
                continue;
            }

            result.Add(index);
            previous = index;
        }

        if (result[^1] != totalCount - 1)
        {
            result.Add(totalCount - 1);
        }

        return result;
    }

    private bool SetField<T>(ref T field, T value, [CallerMemberName] string? propertyName = null)
    {
        if (EqualityComparer<T>.Default.Equals(field, value))
        {
            return false;
        }

        field = value;
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        return true;
    }
}

================================================================================

Файл CaForecast.WpfApp/MainWindow.xaml
--------------------------------------------------------------------------------
<Window x:Class="CaForecast.WpfApp.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:oxy="http://oxyplot.org/wpf"
        mc:Ignorable="d"
        Title="Прогноз на основе трехцветного КА"
        Height="900"
        Width="1280"
        MinHeight="700"
        MinWidth="1024">
    <Window.Resources>
        <BooleanToVisibilityConverter x:Key="BoolToVisibilityConverter" />
    </Window.Resources>
    <Grid Margin="12">
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto" />
            <RowDefinition Height="*" />
            <RowDefinition Height="Auto" />
        </Grid.RowDefinitions>

        <Border Grid.Row="0"
                Padding="12"
                BorderBrush="#DDDDDD"
                BorderThickness="1"
                CornerRadius="8">
            <Grid>
                <Grid.RowDefinitions>
                    <RowDefinition Height="Auto" />
                    <RowDefinition Height="Auto" />
                    <RowDefinition Height="Auto" />
                </Grid.RowDefinitions>

                <DockPanel Grid.Row="0"
                           LastChildFill="True">
                    <Button Content="Загрузить CSV"
                            Command="{Binding LoadCsvCommand}"
                            Width="130"
                            Margin="0,0,8,0"
                            DockPanel.Dock="Left" />
                    <Button Content="Новый API запрос"
                            Command="{Binding ShowMoexInputsCommand}"
                            Width="150"
                            Margin="0,0,8,0"
                            DockPanel.Dock="Left" />
                    <TextBlock Text="{Binding SelectedFilePath}"
                               VerticalAlignment="Center"
                               TextTrimming="CharacterEllipsis"
                               MinWidth="200" />
                </DockPanel>

                <WrapPanel Grid.Row="1"
                           Margin="0,10,0,0"
                           ItemHeight="28">
                    <TextBlock Text="С:"
                               VerticalAlignment="Center"
                               Margin="0,0,6,0" />
                    <TextBox Width="110"
                             Margin="0,0,16,0"
                             Text="{Binding FromDateText, UpdateSourceTrigger=PropertyChanged}"
                             VerticalContentAlignment="Center" />

                    <TextBlock Text="По:"
                               VerticalAlignment="Center"
                               Margin="0,0,6,0" />
                    <TextBox Width="110"
                             Margin="0,0,16,0"
                             Text="{Binding TillDateText, UpdateSourceTrigger=PropertyChanged}"
                             VerticalContentAlignment="Center" />

                    <TextBlock Text="Доля выборки, %:"
                               VerticalAlignment="Center"
                               Margin="0,0,6,0" />
                    <TextBox Width="90"
                             Margin="0,0,16,0"
                             Text="{Binding TrainPercentText, UpdateSourceTrigger=PropertyChanged}"
                             VerticalContentAlignment="Center" />

                    <TextBlock Text="k:"
                               VerticalAlignment="Center"
                               Margin="0,0,6,0" />
                    <TextBox Width="90"
                             Margin="0,0,16,0"
                             Text="{Binding KText, UpdateSourceTrigger=PropertyChanged}"
                             VerticalContentAlignment="Center" />

                    <TextBlock Text="max(m):"
                               VerticalAlignment="Center"
                               Margin="0,0,6,0" />
                    <TextBox Width="90"
                             Margin="0,0,16,0"
                             Text="{Binding MaxMemoryMText, UpdateSourceTrigger=PropertyChanged}"
                             VerticalContentAlignment="Center" />

                    <TextBlock Text="Макс. точек графика:"
                               VerticalAlignment="Center"
                               Margin="0,0,6,0" />
                    <TextBox Width="110"
                             Text="{Binding MaxPlotPointsText, UpdateSourceTrigger=PropertyChanged}"
                             VerticalContentAlignment="Center" />
                </WrapPanel>

                <WrapPanel Grid.Row="2"
                           Margin="0,10,0,0"
                           ItemHeight="28"
                           Visibility="{Binding IsApiInputsVisible, Converter={StaticResource BoolToVisibilityConverter}}">
                    <TextBlock Text="Тикер:"
                               VerticalAlignment="Center"
                               Margin="0,0,6,0" />
                    <TextBox Width="90"
                             Margin="0,0,16,0"
                             Text="{Binding SecIdText, UpdateSourceTrigger=PropertyChanged}"
                             VerticalContentAlignment="Center" />

                    <TextBlock Text="Режим торгов:"
                               VerticalAlignment="Center"
                               Margin="0,0,6,0" />
                    <TextBox Width="90"
                             Margin="0,0,16,0"
                             Text="{Binding BoardIdText, UpdateSourceTrigger=PropertyChanged}"
                             VerticalContentAlignment="Center" />

                    <Button Content="Загрузить MOEX ISS"
                            Command="{Binding LoadMoexCommand}"
                            Width="150"
                            Margin="0,0,8,0" />
                    <Button Content="Скрыть"
                            Command="{Binding HideMoexInputsCommand}"
                            Width="90" />
                </WrapPanel>
            </Grid>
        </Border>

        <Grid Grid.Row="1"
              Margin="0,12,0,12">
            <Grid.ColumnDefinitions>
                <ColumnDefinition Width="2*" MinWidth="420" />
                <ColumnDefinition Width="12" />
                <ColumnDefinition Width="3*" MinWidth="420" />
            </Grid.ColumnDefinitions>
            <Grid.RowDefinitions>
                <RowDefinition Height="*" />
                <RowDefinition Height="12" />
                <RowDefinition Height="Auto" />
            </Grid.RowDefinitions>

            <Border Grid.Column="0"
                    Grid.Row="0"
                    BorderBrush="#DDDDDD"
                    BorderThickness="1"
                    CornerRadius="8"
                    Padding="8">
                <DockPanel>
                    <TextBlock Text="Таблица ошибок по m"
                               FontWeight="SemiBold"
                               DockPanel.Dock="Top"
                               Margin="0,0,0,8" />
                    <DataGrid ItemsSource="{Binding ErrorRows}"
                              AutoGenerateColumns="False"
                              IsReadOnly="True"
                              CanUserAddRows="False"
                              ColumnWidth="Auto"
                              HorizontalScrollBarVisibility="Auto"
                              VerticalScrollBarVisibility="Auto">
                        <DataGrid.Columns>
                            <DataGridTextColumn Header="m" Binding="{Binding Memory}" />
                            <DataGridTextColumn Header="MAE" Binding="{Binding Mae}" />
                            <DataGridTextColumn Header="MSE" Binding="{Binding Mse}" />
                            <DataGridTextColumn Header="RMSE" Binding="{Binding Rmse}" />
                            <DataGridTextColumn Header="MAPE" Binding="{Binding Mape}" />
                        </DataGrid.Columns>
                    </DataGrid>
                </DockPanel>
            </Border>

            <Border Grid.Column="0"
                    Grid.Row="2"
                    BorderBrush="#DDDDDD"
                    BorderThickness="1"
                    CornerRadius="8"
                    Padding="8">
                <DockPanel>
                    <TextBlock Text="Итоговая таблица (лучшее m)"
                               FontWeight="SemiBold"
                               DockPanel.Dock="Top"
                               Margin="0,0,0,8" />
                    <DataGrid ItemsSource="{Binding BestRows}"
                              AutoGenerateColumns="False"
                              IsReadOnly="True"
                              CanUserAddRows="False"
                              ColumnWidth="Auto"
                              HorizontalScrollBarVisibility="Auto"
                              VerticalScrollBarVisibility="Auto"
                              Height="72">
                        <DataGrid.Columns>
                            <DataGridTextColumn Header="m*" Binding="{Binding Memory}" />
                            <DataGridTextColumn Header="MAE, %" Binding="{Binding MaePercent}" />
                            <DataGridTextColumn Header="MSE, %" Binding="{Binding MsePercent}" />
                            <DataGridTextColumn Header="RMSE, %" Binding="{Binding RmsePercent}" />
                            <DataGridTextColumn Header="MAPE, %" Binding="{Binding MapePercent}" />
                        </DataGrid.Columns>
                    </DataGrid>
                </DockPanel>
            </Border>

            <Border Grid.Column="2"
                    Grid.Row="0"
                    Grid.RowSpan="3"
                    BorderBrush="#DDDDDD"
                    BorderThickness="1"
                    CornerRadius="8"
                    Padding="8">
                <DockPanel>
                    <TextBlock Text="График: фактическая и прогнозная цена"
                               FontWeight="SemiBold"
                               DockPanel.Dock="Top"
                               Margin="0,0,0,8" />
                    <oxy:PlotView Model="{Binding PlotModel}"
                                  Controller="{Binding LockedPlotController}" />
                </DockPanel>
            </Border>
        </Grid>

        <DockPanel Grid.Row="2">
            <TextBlock Text="{Binding StatusMessage}"
                       VerticalAlignment="Center"
                       DockPanel.Dock="Left" />
            <ProgressBar Width="220"
                         Height="14"
                         Margin="12,0,0,0"
                         VerticalAlignment="Center"
                         IsIndeterminate="True"
                         Visibility="{Binding IsBusy, Converter={StaticResource BoolToVisibilityConverter}}"
                         DockPanel.Dock="Left" />
            <StackPanel Orientation="Horizontal"
                        HorizontalAlignment="Right"
                        DockPanel.Dock="Right">
                <Button Content="Экспорт результатов"
                        Width="160"
                        Command="{Binding ExportResultsCommand}" />
            </StackPanel>
        </DockPanel>
    </Grid>
</Window>

================================================================================

Файл CaForecast.WpfApp/MainWindow.xaml.cs
--------------------------------------------------------------------------------
using System.Windows;

namespace CaForecast.WpfApp;

public partial class MainWindow : Window
{
    public MainWindow()
    {
        InitializeComponent();
        var viewModel = new MainViewModel();
        DataContext = viewModel;
        Closing += (_, _) => viewModel.CancelBackgroundOperations();
    }
}

================================================================================

Файл CaForecast.WpfApp/MemoryErrorRow.cs
--------------------------------------------------------------------------------
namespace CaForecast.WpfApp;

public class MemoryErrorRow
{
    public int Memory { get; init; }

    public double Mae { get; init; }

    public double Mse { get; init; }

    public double Rmse { get; init; }

    public double Mape { get; init; }
}

================================================================================

Файл CaForecast.WpfApp/RelayCommand.cs
--------------------------------------------------------------------------------
using System;
using System.Windows.Input;

namespace CaForecast.WpfApp;

public class RelayCommand : ICommand
{
    private readonly Action _execute;
    private readonly Func<bool>? _canExecute;

    public RelayCommand(Action execute, Func<bool>? canExecute = null)
    {
        _execute = execute ?? throw new ArgumentNullException(nameof(execute));
        _canExecute = canExecute;
    }

    public event EventHandler? CanExecuteChanged;

    public bool CanExecute(object? parameter)
    {
        return _canExecute?.Invoke() ?? true;
    }

    public void Execute(object? parameter)
    {
        _execute();
    }

    public void RaiseCanExecuteChanged()
    {
        CanExecuteChanged?.Invoke(this, EventArgs.Empty);
    }
}

================================================================================

Файл CaForecast.WpfApp/RunComputationResult.cs
--------------------------------------------------------------------------------
using CaForecast.Core;
using OxyPlot;

namespace CaForecast.WpfApp;

internal sealed class RunComputationResult
{
    public required ForecastResult BestResult { get; init; }

    public required List<MemoryErrorRow> ErrorRows { get; init; }

    public required BestMemoryErrorRow BestRow { get; init; }

    public required List<DateTime?> BestDates { get; init; }

    public required PlotModel PlotModel { get; init; }

    public required double BestMaePercent { get; init; }

    public required double BestMsePercent { get; init; }

    public required double BestRmsePercent { get; init; }
}

================================================================================

