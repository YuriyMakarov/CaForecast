# CaForecast — подробное описание проекта для курсовой

## 1. Введение

В рамках курсовой работы я разработал приложение **CaForecast** — настольную программу для прогноза цены финансового инструмента на основе модели трёхцветного клеточного автомата.

Если объяснять простыми словами, программа берёт исторические биржевые данные, превращает движение цены в последовательность состояний (`падение`, `боковик`, `рост`), учится на этой истории и строит прогноз. После этого она показывает, насколько точным оказался прогноз, и позволяет сохранить результаты.

Для меня было важно сделать не только "математическую идею", но полноценный прикладной инструмент: с интерфейсом, загрузкой данных, визуализацией, сравнением моделей и экспортом результатов.

---

## 2. Актуальность и цель

Финансовые временные ряды сложны и шумные, поэтому в рамках учебного проекта мне было интересно попробовать подход, который:
- не сводится к прямой линейной регрессии;
- даёт интерпретируемую логику переходов между состояниями;
- позволяет экспериментировать с параметрами и сразу видеть эффект.

### Цель работы

Создать программу, которая автоматически:
1. загружает исторические данные;
2. обучает модель на основе клеточного автомата;
3. строит прогноз;
4. оценивает качество прогноза;
5. визуализирует и экспортирует результаты.

### Что реализовано

- Импорт данных из CSV;
- Загрузка данных через **MOEX ISS API** (Московская биржа);
- Подготовка временного ряда и фильтрация;
- Обучение модели для набора значений памяти `m`;
- Расчёт метрик ошибок (MAE, MSE, RMSE, MAPE);
- Выбор лучшей модели;
- График "факт/прогноз";
- Экспорт результата в CSV.

---

## 3. Общая идея работы программы

Я строю прогноз не напрямую по цене, а через несколько этапов:

1. Получаю историю цен закрытия.
2. Считаю лог-доходности между соседними точками.
3. Кодирую каждую доходность в одно из трёх состояний:
   - `-1` — заметное падение,
   - `0` — нейтральное изменение,
   - `1` — заметный рост.
4. Смотрю, как в истории после определённого шаблона состояний чаще всего ведёт себя следующий шаг.
5. Использую эти вероятностные правила на тестовой части ряда.
6. Восстанавливаю прогнозную цену и сравниваю её с фактической.

То есть логика такая: модель учится на "поведенческих паттернах" движения, а не на одном фиксированном уравнении.

---

## 4. Архитектура решения

Я разделил проект на три слоя, чтобы ответственность каждого блока была чёткой.

## 4.1. Слой представления — `CaForecast.WpfApp`

Это WPF-приложение, с которым взаимодействует пользователь.

Что здесь происходит:
- Ввод параметров (даты, порог, память, доля выборки и др.);
- Запуск загрузки и расчёта;
- Отображение таблиц и графика;
- Показ сообщений об ошибках/статусе;
- Экспорт результата.

Ключевая роль слоя: быть "дирижёром" всего сценария, но не выполнять вычислительную математику внутри UI.

### Ключевые файлы

- `MainWindow.xaml` — визуальная разметка окна.
- `MainViewModel.cs` — центральная точка сценария: связка UI + сервисы.
- `RelayCommand.cs` — команды для кнопок и действий пользователя.
- `ViewModels/Rows/*.cs` — модели строк для таблиц в интерфейсе.

## 4.2. Слой доменной логики — `CaForecast.Core`

Это "ядро" проекта. Здесь нет привязки к интерфейсу и внешним API: только алгоритмы и вычисления.

Основные сервисы:

- `ReturnCalculator` — считает лог-доходности по ценам;
- `ThreeColorEncoder` — превращает доходности в трёхцветные состояния;
- `CaRuleTrainer` — обучает правила переходов для выбранной памяти `m`;
- `CaForecaster` — строит прогноз доходностей и цены;
- `MetricsService` — вычисляет ошибки прогноза.

Ключевая роль слоя: обеспечивать корректный, переиспользуемый и тестируемый алгоритм.

## 4.3. Слой данных — `CaForecast.Data`

Этот слой отвечает за связь приложения с внешним миром.

Сервисы слоя:

- `CsvImportService` — импорт данных из CSV;
- `MoexIssService` — запросы к MOEX ISS API;
- `CsvExportService` — экспорт результатов.

Также в этом проекте лежат модели данных для импорта/экспорта.

Ключевая роль слоя: забрать/сохранить данные и отдать их в удобном формате дальше по цепочке.

---

## 5. Подробный сценарий работы (как в реальном использовании)

Ниже рассказываю так, как пользователь реально работает в программе.

### Шаг 1. Выбор источника данных

Пользователь может:
- выбрать CSV-файл с историей,
- или загрузить историю с Московской биржи (через MOEX API).

Если выбран MOEX:
- вводится тикер и период;
- сервис запрашивает данные по истории торгов;
- при большом диапазоне используется пагинация;
- в программу возвращаются даты и цены закрытия.

### Шаг 2. Проверка и подготовка данных

На этом этапе:
- удаляются некорректные или пустые значения;
- применяется фильтр по диапазону дат;
- проверяется, что данных достаточно для расчёта.

Если данных мало или формат неверный, приложение показывает понятное сообщение, а не падает с исключением.

### Шаг 3. Переход от цен к доходностям

Из ценового ряда `P` рассчитывается лог-доходность:

`r_t = ln(P_t / P_{t-1})`

Почему так:
- это стандартный подход в финмоделях;
- доходности удобнее сравнивать между разными участками;
- они лучше подходят для кодирования состояний.

### Шаг 4. Трёхцветное кодирование

По порогу `k` каждая доходность переводится в состояние:
- `r > k` => `1`;
- `r < -k` => `-1`;
- иначе => `0`.

Смысл этого шага: модель работает не с "бесконечным" набором чисел, а с компактным алфавитом состояний. Это делает переходы и паттерны явными.

### Шаг 5. Обучение модели для разных `m`

`m` — это глубина памяти автомата. Она показывает, сколько предыдущих состояний модель учитывает, когда предсказывает следующее.

Я не фиксирую одно `m`, а прогоняю диапазон: `1..max(m)`.

Для каждого `m`:
- формируются шаблоны длины `m`;
- считается статистика следующего состояния;
- строятся вероятности перехода.

Идея простая: если в истории после шаблона `1,0,-1` чаще всего идёт `0`, то модель это запоминает как наиболее вероятный переход.

### Шаг 6. Прогноз на тестовой части

После обучения для каждого `m` выполняется прогноз:
- берётся текущий шаблон последних `m` состояний;
- из правил выбирается наиболее вероятное следующее состояние;
- состояние переводится в ожидаемую доходность;
- на её основе обновляется прогнозная цена.

Так шаг за шагом строится весь прогнозный ряд.

### Шаг 7. Оценка качества и выбор лучшей модели

Для каждого `m` считаются:
- **MAE** — средняя абсолютная ошибка;
- **MSE** — средняя квадратичная ошибка;
- **RMSE** — корень из MSE;
- **MAPE** — средняя относительная ошибка в процентах.

Дальше выбирается лучшее `m` по минимальному RMSE.

Пользователь получает не только "один прогноз", а полноценное сравнение конфигураций памяти.

### Шаг 8. Визуализация

В интерфейсе строится график:
- фактическая цена;
- прогнозная цена.

Это позволяет сразу увидеть, где модель повторяет тренд хорошо, а где начинает запаздывать или ошибаться на разворотах.

### Шаг 9. Экспорт

Результат сохраняется в CSV:
- таблица метрик по памяти;
- информация о лучшей модели;
- точки прогноза (дата, факт, прогноз).

Это удобно для отчёта и дополнительного анализа в Excel/ноутбуках.

---

## 6. Как и зачем используется Московская биржа (MOEX ISS API)

Использование MOEX — это практический плюс проекта.

Вместо ручной подготовки файлов можно получить данные напрямую из биржевого источника. Это даёт:
- актуальность данных;
- удобство повторных экспериментов;
- единый формат котировок.

### Что делает сервис `MoexIssService`

- Формирует HTTP-запрос к endpoint истории;
- Получает JSON-ответ;
- Извлекает дату торгов и цену закрытия;
- Обрабатывает несколько страниц ответа, если период большой;
- Возвращает в приложение очищенный ряд.

Также обрабатываются типовые проблемы:
- ошибки HTTP;
- пустой ответ;
- некорректный период;
- проблемы формата данных.

Таким образом, пользователь работает с моделью, а детали сетевого обмена скрыты в инфраструктурном слое.

---

## 7. Что важно в реализации с инженерной точки зрения

1. Разделение ответственности.
UI, математика и доступ к данным вынесены в разные проекты. Это облегчает поддержку и развитие.

2. Переиспользуемость логики.
Алгоритмы находятся в `Core` и могут использоваться вне WPF.

3. Устойчивость к ошибкам данных.
Импорт/загрузка включают проверки и валидацию.

4. Практический фокус.
Вместо абстрактного "вывода формулы" пользователь получает инструмент, где можно загрузить данные, настроить параметры, увидеть график и сохранить итог.

---

## 8. Ограничения текущей версии

Как и любой учебный проект, текущая версия имеет ограничения:

- Приложение WPF, поэтому основной запуск ориентирован на Windows.
- Модель использует дискретизацию `-1/0/1`, что упрощает динамику рынка.
- Качество прогноза зависит от выбранных параметров (`k`, `m`, длина train/test).
- На сильных структурных сдвигах рынка точность может снижаться.

Эти ограничения я осознанно принимаю как часть выбранного подхода и масштаба курсовой работы.

---

## 9. Что я считаю результатом работы

Для меня ключевой результат в том, что получилась **целостная система**, а не отдельный скрипт:

- есть архитектура и разделение слоёв;
- есть два источника данных (CSV и MOEX API);
- есть реализованный алгоритм прогнозирования;
- есть объективная оценка качества;
- есть визуализация и экспорт для отчётности.

То есть проект закрывает полный путь: **данные -> модель -> прогноз -> оценка -> отчёт**.

---

## 10. Заключение (как я бы сказал на защите)

В этой работе я реализовал приложение, которое демонстрирует, как можно применять идею клеточного автомата для задачи прогноза финансового ряда в прикладной форме.

Я сделал акцент на том, чтобы проект был удобен в использовании и понятен по структуре: отдельно интерфейс, отдельно вычислительное ядро, отдельно работа с внешними источниками.

С практической стороны программа позволяет быстро получить данные (в том числе с Московской биржи), провести серию расчётов по разным параметрам памяти, сравнить качество и сохранить результат в отчёт.

Именно это, на мой взгляд, и является ценностью курсовой: не только показать метод, но и довести его до рабочего инструмента.
